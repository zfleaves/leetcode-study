<!--
 * @Date: 2023-11-20 19:35:21
 * @LastEditors: zhangming 1051403128@qq.com
 * @LastEditTime: 2023-11-20 19:37:56
 * @FilePath: \leetcode-study\简单\index-83.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>最后一个单词的长度</title>
    <link rel="stylesheet" href="../common.css" />
</head>

<body>
    <div class="px-5 pt-4">
        <div class="flex"></div>
        <div class="xFUwe" data-track-load="description_content">
            <p>给定一个已排序的链表的头
                <meta charset="UTF-8">&nbsp;<code>head</code>&nbsp;，&nbsp;<em>删除所有重复的元素，使每个元素只出现一次</em>&nbsp;。返回
                <em>已排序的链表</em>&nbsp;。</p>

            <p>&nbsp;</p>

            <p><strong>示例 1：</strong></p>
            <img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg"
                style="height: 160px; width: 200px;">
            <pre><strong>输入：</strong>head = [1,1,2]
        <strong>输出：</strong>[1,2]
        </pre>

            <p><strong>示例 2：</strong></p>
            <img alt="" src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg"
                style="height: 123px; width: 300px;">
            <pre><strong>输入：</strong>head = [1,1,2,3,3]
        <strong>输出：</strong>[1,2,3]
        </pre>

            <p>&nbsp;</p>

            <p><strong>提示：</strong></p>

            <ul>
                <li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
                <li><code>-100 &lt;= Node.val &lt;= 100</code></li>
                <li>题目数据保证链表已经按升序 <strong>排列</strong></li>
            </ul>
        </div>
    </div>
    <div class="analysis">
        由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素
        <br>
        具体地，我们从指针 cur\textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur\textit{cur}cur 与 cur.next\textit{cur.next}cur.next
        对应的元素相同，那么我们就将 cur.next\textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur\textit{cur}cur 对应的元素相同的节点，因此可以将
        cur\textit{cur}cur 指向 cur.next\textit{cur.next}cur.next。
        <br>
        当遍历完整个链表之后，我们返回链表的头节点即可。
        <br>
        当我们遍历到链表的最后一个节点时，cur.next\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 cur.next\textit{cur.next}cur.next
        对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。
    </div>
    <script>
        var deleteDuplicates = function (head) {
            if (!head) {
                return head;
            }

            let cur = head;
            while (cur.next) {
                if (cur.val === cur.next.val) {
                    cur.next = cur.next.next;
                } else {
                    cur = cur.next;
                }
            }
            return head;
        };
        const head = [1, 1, 2];
        const result = deleteDuplicates(head);
        console.log("result: ", result);
    </script>
</body>

</html>
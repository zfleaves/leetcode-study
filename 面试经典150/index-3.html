<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>无重复字符的最长子串</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长 <span data-keyword="substring-nonempty" class=" cursor-pointer relative text-dark-blue-s text-sm"><div class="popover-wrapper inline-block" data-headlessui-state=""><div><div aria-expanded="false" data-headlessui-state="" id="headlessui-popover-button-:rnk:"><div>子串</div></div><div style="position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(405px, 183px);"></div></div></div></span></strong><strong>&nbsp;</strong>的长度。</p>

        <p>&nbsp;</p>

        <p><strong>示例&nbsp;1:</strong></p>

        <pre><strong>输入: </strong>s = "abcabcbb"
        <strong>输出: </strong>3 
        <strong>解释:</strong> 因为无重复字符的最长子串是 <code>"abc"</code>，所以其长度为 3。
        </pre>

        <p><strong>示例 2:</strong></p>

        <pre><strong>输入: </strong>s = "bbbbb"
        <strong>输出: </strong>1
        <strong>解释: </strong>因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。
        </pre>

        <p><strong>示例 3:</strong></p>

        <pre><strong>输入: </strong>s = "pwwkew"
        <strong>输出: </strong>3
        <strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>"wke"</code>，所以其长度为 3。
        &nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>"pwke"</code>&nbsp;是一个<em>子序列，</em>不是子串。
        </pre>

        <p>&nbsp;</p>

        <p><strong>提示：</strong></p>

        <ul>
            <li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
            <li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>
        </ul>
    </div>
    <div class="analysis">
        妙啊， 这个算法的核心思想在于。如果n1+n2+n3满足>=target，那么说明n1+n2是不满足的。所以left左指针往右移动，再判断是否满足，就能找到最小满足的了。
    </div>
    </div>
    <script>
        /**
         * @param {string} s
         * @return {number}
         */
        var lengthOfLongestSubstring = function(s) {
            const occ = new Set()
            const n = s.length
            let rk = -1;
            let ans = 0
            for (let i = 0; i < n; i++) {
                if (i !== 0) {
                    occ.delete(s.charAt(i - 1))
                }
                while(rk + 1 < n && !occ.has(s.charAt(rk + 1))) {
                    occ.add(s.charAt(rk + 1))
                    ++rk
                }
                ans = Math.max(ans, rk - i + 1)
            }
            return ans
        };
        const s = " "
        const result = lengthOfLongestSubstring(s);
        console.log("result: ", result);
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>电话号码的字母组合</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>

        <p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
        
        <p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" style="width: 200px;"></p>
        
        <p>&nbsp;</p>
        
        <p><strong>示例 1：</strong></p>
        
        <pre><strong>输入：</strong>digits = "23"
        <strong>输出：</strong>["ad","ae","af","bd","be","bf","cd","ce","cf"]
        </pre>
        
        <p><strong>示例 2：</strong></p>
        
        <pre><strong>输入：</strong>digits = ""
        <strong>输出：</strong>[]
        </pre>
        
        <p><strong>示例 3：</strong></p>
        
        <pre><strong>输入：</strong>digits = "2"
        <strong>输出：</strong>["a","b","c"]
        </pre>
        
        <p>&nbsp;</p>
        
        <p><strong>提示：</strong></p>
        
        <ul>
            <li><code>0 &lt;= digits.length &lt;= 4</code></li>
            <li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li>
        </ul>
        </div>
    <div class="analysis">
        <h2 id="回溯法来解决n个for循环的问题">回溯法来解决n个for循环的问题</h2>
        <p>对于回溯法还不了解的同学看这篇：<a href="/link/?target=https%3A%2F%2Fprogrammercarl.com%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" target="_blank">关于回溯算法，你该了解这些！</a></p>
        <p>例如：输入："23"，抽象为树形结构，如图所示：</p>
        <p><img src="https://pic.leetcode.cn/1671681675-CXuntT-image.png" alt="image.png"></p>
        <p>图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。</p>
        <p>图中可以看出遍历的深度，就是输入"23"的长度，而叶子节点就是我们要收集的结果，输出["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]。</p>
        <p>回溯三部曲：</p>
        <ul>
            <li>确定回溯函数参数</li>
        </ul>
        <p>首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。</p>
        <p>再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index。</p>
        <ul>
            <li>确定终止条件</li>
        </ul>
        <p>例如输入用例"23"，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。</p>
        <p>那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。</p>
        <p>然后收集结果，结束本层递归。</p>

    </div>
    </div>
    <script>
        /**
         * @param {string} digits
         * @return {string[]}
         */
        var letterCombinations = function (digits) {
            const len = digits.length;
            const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];
            if (!len) return [];
            if (len === 1) return map[digits].split("");

            const res = [], path = [];
            backtracking(digits, len, 0);
            return res;

            function backtracking(digits, len, i) {
                if (path.length === len) { // 循环到底后，当i=0 时 相当于 path 里面会存入 [a, d]
                    res.push(path.join(""));
                    return;
                }
                for (const v of map[digits[i]]) {
                    path.push(v);
                    backtracking(digits, len, i + 1);
                    path.pop(); // 循环后，有 d 切换到 e 把循环的上一个字母给删除掉
                }
            }
        };
        const digits = "23"
        const result = letterCombinations(digits);
        console.log("result: ", result);
    </script>
</body>

</html>
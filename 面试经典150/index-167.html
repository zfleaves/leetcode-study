<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>反转字符串中的单词</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给你一个下标从 <strong>1</strong> 开始的整数数组&nbsp;<code>numbers</code> ，该数组已按<strong><em> </em>非递减顺序排列&nbsp; </strong>，请你从数组中找出满足相加之和等于目标数&nbsp;<code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index<sub>1</sub>]</code> 和 <code>numbers[index<sub>2</sub>]</code> ，则 <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code> 。</p>

        <p>以长度为 2 的整数数组 <code>[index<sub>1</sub>, index<sub>2</sub>]</code> 的形式返回这两个整数的下标 <code>index<sub>1</sub></code><em> </em>和<em> </em><code>index<sub>2</sub></code>。</p>
        
        <p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
        
        <p>你所设计的解决方案必须只使用常量级的额外空间。</p>
        &nbsp;
        
        <p><strong class="example">示例 1：</strong></p>
        
        <pre><strong>输入：</strong>numbers = [<strong><em>2</em></strong>,<strong><em>7</em></strong>,11,15], target = 9
        <strong>输出：</strong>[1,2]
        <strong>解释：</strong>2 与 7 之和等于目标数 9 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。</pre>
        
        <p><strong class="example">示例 2：</strong></p>
        
        <pre><strong>输入：</strong>numbers = [<strong><em>2</em></strong>,3,<strong><em>4</em></strong>], target = 6
        <strong>输出：</strong>[1,3]
        <strong>解释：</strong>2 与 4 之和等于目标数 6 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 3 。返回 [1, 3] 。</pre>
        
        <p><strong class="example">示例 3：</strong></p>
        
        <pre><strong>输入：</strong>numbers = [<strong><em>-1</em></strong>,<strong><em>0</em></strong>], target = -1
        <strong>输出：</strong>[1,2]
        <strong>解释：</strong>-1 与 0 之和等于目标数 -1 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。
        </pre>
        
        <p>&nbsp;</p>
        
        <p><strong>提示：</strong></p>
        
        <ul>
            <li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>
            <li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
            <li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
            <li><code>-1000 &lt;= target &lt;= 1000</code></li>
            <li><strong>仅存在一个有效答案</strong></li>
        </ul>
        </div>
    <div class="analysis">
        <ol>
            <li>使用双指针的方法，从后向前遍历字符</li>
            <li>右端的指针遇到空格跳过，直到单词的末尾，然后将左端的指针指向右端</li>
            <li>在2的基础上，左指针继续向前，直到遇到空格或小于0才停下（此时左右指针之间就是单词）</li>
            <li>把单词添加到结果字符串中，然后把右指针指向左指针，开始下一轮遍历</li>
            <li>下一轮遍历开始后，如果还有新单词，就给上一个单词后面添加一个空格</li>
        </ol>
    </div>
    </div>
    <script>
        /**
         * @param {number[]} numbers
         * @param {number} target
         * @return {number[]}
         */
        var twoSum = function (numbers, target) {
            let i = 0
            let j = 1
            while (i < numbers.length && j < numbers.length) {
                const total = numbers[i] + numbers[j]
                if (total === target) {
                    return [i + 1, j + 1]
                }
                if (total !== target && j < numbers.length - 1) {
                    j++
                } else {
                    i++
                }
            }
            return []
        };
        const numbers = [3,24,50,79,88,150,345]
        const target = 200
        const result = twoSum(numbers, target);
        console.log("result: ", result);
    </script>
</body>

</html>
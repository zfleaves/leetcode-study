<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>串联所有单词的子串</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给定一个字符串&nbsp;<code>s</code><strong>&nbsp;</strong>和一个字符串数组&nbsp;<code>words</code><strong>。</strong>&nbsp;<code>words</code>&nbsp;中所有字符串 <strong>长度相同</strong>。</p>

        <p>&nbsp;<code>s</code><strong>&nbsp;</strong>中的 <strong>串联子串</strong> 是指一个包含&nbsp;&nbsp;<code>words</code>&nbsp;中所有字符串以任意顺序排列连接起来的子串。</p>
        
        <ul>
            <li>例如，如果&nbsp;<code>words = ["ab","cd","ef"]</code>， 那么&nbsp;<code>"abcdef"</code>，&nbsp;<code>"abefcd"</code>，<code>"cdabef"</code>，&nbsp;<code>"cdefab"</code>，<code>"efabcd"</code>， 和&nbsp;<code>"efcdab"</code> 都是串联子串。&nbsp;<code>"acdbef"</code> 不是串联子串，因为他不是任何&nbsp;<code>words</code>&nbsp;排列的连接。</li>
        </ul>
        
        <p>返回所有串联子串在&nbsp;<code>s</code><strong>&nbsp;</strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>
        
        <p>&nbsp;</p>
        
        <p><strong>示例 1：</strong></p>
        
        <pre><strong>输入：</strong>s = "barfoothefoobarman", words = ["foo","bar"]
        <strong>输出：</strong><code>[0,9]</code>
        <strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。
        子串 "barfoo" 开始位置是 0。它是 words 中以 ["bar","foo"] 顺序排列的连接。
        子串 "foobar" 开始位置是 9。它是 words 中以 ["foo","bar"] 顺序排列的连接。
        输出顺序无关紧要。返回 [9,0] 也是可以的。
        </pre>
        
        <p><strong>示例 2：</strong></p>
        
        <pre><strong>输入：</strong>s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
        <code><strong>输出：</strong>[]</code>
        <strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。
        s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。
        所以我们返回一个空数组。
        </pre>
        
        <p><strong>示例 3：</strong></p>
        
        <pre><strong>输入：</strong>s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
        <strong>输出：</strong>[6,9,12]
        <strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。
        子串 "foobarthe" 开始位置是 6。它是 words 中以 ["foo","bar","the"] 顺序排列的连接。
        子串 "barthefoo" 开始位置是 9。它是 words 中以 ["bar","the","foo"] 顺序排列的连接。
        子串 "thefoobar" 开始位置是 12。它是 words 中以 ["the","foo","bar"] 顺序排列的连接。</pre>
        
        <p>&nbsp;</p>
        
        <p><strong>提示：</strong></p>
        
        <ul>
            <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
            <li><code>1 &lt;= words.length &lt;= 5000</code></li>
            <li><code>1 &lt;= words[i].length &lt;= 30</code></li>
            <li><code>words[i]</code>&nbsp;和&nbsp;<code>s</code> 由小写英文字母组成</li>
        </ul>
    </div>
    <div class="analysis">
        妙啊， 这个算法的核心思想在于。如果n1+n2+n3满足>=target，那么说明n1+n2是不满足的。所以left左指针往右移动，再判断是否满足，就能找到最小满足的了。
    </div>
    </div>
    <script>
        /**
         * @param {string} s
         * @param {string[]} words
         * @return {number[]}
         */
        var findSubstring = function (s, words) {
            const total = words.join('').length
            if (total.length > s.length) return []
            const res = []
            const list = permuteUnique(words)
            console.log('list: ', list);
            for (const item of list) {
                const index = s.indexOf(item)
                if (index > -1) {
                    res.push(index)
                }
            }
            // 获取words 组合
            function permuteUnique(arr) {
                // 辅助函数，用于递归生成排列  
                function permute(arr, m, permutations = []) {
                    // 如果所有字符都已经被使用  
                    if (m === 0) {
                        permutations.push(arr.join('')); // 将当前排列加入结果集  
                    } else {
                        // 遍历所有字符  
                        for (let i = 0; i <= m - 1; i++) {
                            // 将当前字符与后面的字符交换  
                            [arr[m - 1], arr[i]] = [arr[i], arr[m - 1]];

                            // 使用剩余未使用的字符继续递归  
                            permute(arr, m - 1, permutations);

                            // 交换回来，以进行下一次迭代  
                            [arr[m - 1], arr[i]] = [arr[i], arr[m - 1]];
                        }
                    }
                    return permutations;
                }

                // 复制数组，因为我们要修改它  
                const arrCopy = [...arr];
                // 获取数组长度  
                const len = arrCopy.length;
                // 调用辅助函数生成排列  
                return [...new Set(permute(arrCopy, len))];
            }
            return res
        };
        const s = "wordgoodgoodgoodbestword"
        const words = ["word","good","best","good"]
        const result = findSubstring(s, words);
        console.log("result: ", result);
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>加油站</title>
    <link rel="stylesheet" href="../common.css" as="style" />
  </head>
  <body>
    <div class="elfjS" data-track-load="description_content">
      <p>
        在一条环路上有 <code>n</code>&nbsp;个加油站，其中第
        <code>i</code>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code
        ><em>&nbsp;</em>升。
      </p>

      <p>
        你有一辆油箱容量无限的的汽车，从第<em> </em><code>i</code
        ><em> </em>个加油站开往第<em> </em><code>i+1</code
        ><em>&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code
        ><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。
      </p>

      <p>
        给定两个整数数组 <code>gas</code> 和
        <code>cost</code>
        ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回
        <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是
        <strong>唯一</strong> 的。
      </p>

      <p>&nbsp;</p>

      <p><strong>示例&nbsp;1:</strong></p>

      <pre><strong>输入:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]
        <strong>输出:</strong> 3
        <strong>解释:
        </strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
        开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
        开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
        开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
        开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
        开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
        因此，3 可为起始索引。</pre>

      <p><strong>示例 2:</strong></p>

      <pre><strong>输入:</strong> gas = [2,3,4], cost = [3,4,3]
        <strong>输出:</strong> -1
        <strong>解释:
        </strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
        我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
        开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
        开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
        你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
        因此，无论怎样，你都不可能绕环路行驶一周。</pre>

      <p>&nbsp;</p>

      <p><strong>提示:</strong></p>

      <ul>
        <li><code>gas.length == n</code></li>
        <li><code>cost.length == n</code></li>
        <li>
          <code>1 &lt;= n &lt;= 10<sup>5</sup></code>
        </li>
        <li>
          <code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code>
        </li>
      </ul>
    </div>
    <div class="analysis">
      <ol>
        <li>
          规律总结：如果x到不了y+1（但能到y），那么从x到y的任一点出发都不可能到达y+1。
          因为从其中任一点出发的话，相当于从0开始加油，而如果从x出发到该点则不一定是从0开始加油，可能还有剩余的油。
          既然不从0开始都到不了y+1，那么从0开始就更不可能到达y+1。
          注意，有一个前提条件，是从其中的任一点【出发】，如果是【途经】，那么这个规律不一定成立。因为我们就是在找从【出发】
          型的解，那么这个规律正好可以用上，用来快速排除一定量的非解。
        </li>
        <li>
          因此，当某个点x出发按顺序无法到达y+1点时，[x,y]内的所有点都无法到达y+1点，那么这部分的点可以直接跳过不做检查。
        </li>
        <li>
          已知：如果存在解，则存在的解对应的那个点ans，可以按顺序到达包括自身在内的所有点，即n个不同的点。
          同时，总共n个点，当前x已有不能到达的点了，那么从x出发可以抵达的点的数量一定小于n，不满足已知。那么[x,y]之间
          的所有点均可以排除。
          那么潜在的解就可以从y+1点继续排查，即令x=y+1。直至到达某个x时，可以抵达点的个数为n，那么就是解了，已知解唯一，
          则可直接返回。如果排查了一遍都没有这样的解，那么就无解，返回-1。
        </li>
      </ol>
    </div>
    <script>
      /**
       * @param {number[]} gas
       * @param {number[]} cost
       * @return {number}
       */
      var canCompleteCircuit = function (gas, cost) {
        let i = 0;
        const n = gas.length;
        while (i < n) {
          let sumGas = 0;
          let sumCost = 0;
          let cur = 0;
          while (cur < n) {
            const j = (i + cur) % n;
            sumGas += gas[j];
            sumCost += cost[j];
            if (sumGas < sumCost) {
              break;
            }
            cur++;
          }
          if (cur === n) {
            return i;
          } else {
            i = i + 1 + cur;
          }
        }
        return -1;
      };
      const gas = [1,2,3,4,5];
      const cost = [3,4,5,1,2]
      const result = canCompleteCircuit(gas, cost);
      console.log("result: ", result);
    </script>
  </body>
</html>

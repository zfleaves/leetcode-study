<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>单词规律</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给定一种规律 <code>pattern</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，判断 <code>s</code>&nbsp;是否遵循相同的规律。</p>

        <p>这里的&nbsp;<strong>遵循&nbsp;</strong>指完全匹配，例如，&nbsp;<code>pattern</code>&nbsp;里的每个字母和字符串&nbsp;<code>s</code><strong>&nbsp;</strong>中的每个非空单词之间存在着双向连接的对应规律。</p>
        
        <p>&nbsp;</p>
        
        <p><strong>示例1:</strong></p>
        
        <pre><strong>输入:</strong> pattern = <code>"abba"</code>, s = <code>"dog cat cat dog"</code>
        <strong>输出:</strong> true</pre>
        
        <p><strong>示例 2:</strong></p>
        
        <pre><strong>输入:</strong>pattern = <code>"abba"</code>, s = <code>"dog cat cat fish"</code>
        <strong>输出:</strong> false</pre>
        
        <p><strong>示例 3:</strong></p>
        
        <pre><strong>输入:</strong> pattern = <code>"aaaa"</code>, s = <code>"dog cat cat dog"</code>
        <strong>输出:</strong> false</pre>
        
        <p>&nbsp;</p>
        
        <p><strong>提示:</strong></p>
        
        <ul>
            <li><code>1 &lt;= pattern.length &lt;= 300</code></li>
            <li><code>pattern</code>&nbsp;只包含小写英文字母</li>
            <li><code>1 &lt;= s.length &lt;= 3000</code></li>
            <li><code>s</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code></li>
            <li><code>s</code>&nbsp;<strong>不包含</strong> 任何前导或尾随对空格</li>
            <li><code>s</code>&nbsp;中每个单词都被 <strong>单个空格 </strong>分隔</li>
        </ul>
        </div>
    <div class="analysis">
        妙啊， 这个算法的核心思想在于。如果n1+n2+n3满足>=target，那么说明n1+n2是不满足的。所以left左指针往右移动，再判断是否满足，就能找到最小满足的了。
    </div>
    </div>
    <script>
        /**
         * @param {string} pattern
         * @param {string} s
         * @return {boolean}
         */
        var wordPattern = function(pattern, s) {
            const word2ch = new Map();
            const ch2word = new Map();
            const words = s.split(' ');
            if (pattern.length !== words.length) {
                return false;
            }
            for (const [i, word] of words.entries()) {
                const ch = pattern[i];
                if (word2ch.has(word) && word2ch.get(word) != ch || ch2word.has(ch) && ch2word.get(ch) !== word) {
                    return false;
                }
                word2ch.set(word, ch);
                ch2word.set(ch, word);
            }
            return true
        };
        const pattern = "abc"
        const s = 'dog cat dog'
        const result = wordPattern(pattern, s);
        console.log("result: ", result);
    </script>
</body>

</html>
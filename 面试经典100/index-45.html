<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>跳跃游戏 II</title>
    <link rel="stylesheet" href="../common.css" as="style" />
  </head>
  <body>
    <div class="elfjS" data-track-load="description_content">
      <p>
        给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组
        <code>nums</code>。初始位置为 <code>nums[0]</code>。
      </p>

      <p>
        每个元素 <code>nums[i]</code> 表示从索引
        <code>i</code> 向前跳转的最大长度。换句话说，如果你在
        <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:
      </p>

      <ul>
        <li><code>0 &lt;= j &lt;= nums[i]</code>&nbsp;</li>
        <li><code>i + j &lt; n</code></li>
      </ul>

      <p>
        返回到达&nbsp;<code>nums[n - 1]</code>
        的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。
      </p>

      <p>&nbsp;</p>

      <p><strong>示例 1:</strong></p>

      <pre><strong>输入:</strong> nums = [2,3,1,1,4]
        <strong>输出:</strong> 2
        <strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。
        &nbsp;    从下标为 0 跳到下标为 1 的位置，跳&nbsp;<code>1</code>&nbsp;步，然后跳&nbsp;<code>3</code>&nbsp;步到达数组的最后一个位置。
        </pre>

      <p><strong>示例 2:</strong></p>

      <pre><strong>输入:</strong> nums = [2,3,0,1,4]
        <strong>输出:</strong> 2
        </pre>

      <p>&nbsp;</p>

      <p><strong>提示:</strong></p>

      <ul>
        <li>
          <code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code>
        </li>
        <li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
        <li>题目保证可以到达&nbsp;<code>nums[n-1]</code></li>
      </ul>
    </div>
    <div class="analysis">
      <h1 id="思路">思路</h1>
      <p>
        因为要尽可能少的步数，那么每次都要走最大的长度，等同于找可到达索引内的最大值。
      </p>
      <p>
        例如[2,3,1,1,4]，在i=0时，可覆盖到（索引+值）：0+2=2，即：索引1、索引2，在该范围内找到最大的值是：索引1+值3，那么下一个范围就到：索引1+值3=4，即到索引4。
      </p>
      <h1 id="解题方法">解题方法</h1>
      <ol>
        <li>
          循环遍历数组，在当前范围内找下一个可到达的最大值，赋值给下一个范围变量。
        </li>
        <li>
          当i走到当前范围的边界时，步数就加1，向前一步，走进下一个范围，下一个范围赋值给当前范围。
        </li>
        <li>需要3个变量：当前范围，下一个范围，以及步数</li>
      </ol>
    </div>
    <script>
      /**
       * @param {number[]} nums
       * @return {number}
       */
      var jump = function (nums) {
        let step = 0;
        let curDistance = 0;
        let nextDistance = 0; // 在当前范围内找下一次可到达的最大范围
        // 前提：题目保证可以到达 nums[n-1]
        // 最后一个索引不需要遍历，因为是到达的点，不是经过的点，到了终点步数不需要加1
        for (var i = 0; i < nums.length - 1; i++) {
          nextDistance = Math.max(nextDistance, nums[i] + i);
          // 遍历到倒数第二个值即可，倒二需要走则+1，不需要走则说明直接到终点
          if (curDistance === i) {
            // 说明移动到范围的边界了，需要向前一步，进入下一个范围，步数加1，范围更新为下一个范围
            step++;
            curDistance = nextDistance;
          }
        }
        return step;
      };
      const nums = [2,3,1,1,4]
      const result = jump(nums);
      console.log("result: ", result);
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>插入区间</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
      span.katex-mathml {
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="elfjS" data-track-load="description_content">
      <p>
        给你一个<strong> 无重叠的</strong
        ><em> ，</em>按照区间起始端点排序的区间列表
        <code>intervals</code>，其中&nbsp;<code
          >intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code
        >&nbsp;表示第&nbsp;<code>i</code>&nbsp;个区间的开始和结束，并且&nbsp;<code>intervals</code>&nbsp;按照&nbsp;<code
          >start<sub>i</sub></code
        >&nbsp;升序排列。同样给定一个区间&nbsp;<code
          >newInterval = [start, end]</code
        >&nbsp;表示另一个区间的开始和结束。
      </p>

      <p>
        在&nbsp;<code>intervals</code>
        中插入区间&nbsp;<code>newInterval</code>，使得&nbsp;<code>intervals</code>&nbsp;依然按照&nbsp;<code
          >start<sub>i</sub></code
        >&nbsp;升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。
      </p>

      <p>返回插入之后的&nbsp;<code>intervals</code>。</p>

      <p>
        <strong>注意</strong>
        你不需要原地修改&nbsp;<code>intervals</code>。你可以创建一个新数组然后返回它。
      </p>

      <p>&nbsp;</p>

      <p><strong>示例&nbsp;1：</strong></p>

      <pre><strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]
        <strong>输出：</strong>[[1,5],[6,9]]
        </pre>

      <p><strong>示例 2：</strong></p>

      <pre><strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
        <strong>输出：</strong>[[1,2],[3,10],[12,16]]
        <strong>解释：</strong>这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code>&nbsp;重叠。
        </pre>

      <p>&nbsp;</p>

      <p><strong>提示：</strong></p>

      <ul>
        <li>
          <code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code>
        </li>
        <li><code>intervals[i].length == 2</code></li>
        <li>
          <code
            >0 &lt;=&nbsp;start<sub>i</sub> &lt;=&nbsp;end<sub>i</sub> &lt;=
            10<sup>5</sup></code
          >
        </li>
        <li>
          <code>intervals</code> 根据 <code>start<sub>i</sub></code> 按
          <strong>升序</strong> 排列
        </li>
        <li><code>newInterval.length == 2</code></li>
        <li>
          <code>0 &lt;=&nbsp;start &lt;=&nbsp;end &lt;= 10<sup>5</sup></code>
        </li>
      </ul>
    </div>
    <div class="analysis">
      <div class="FN9Jv WRmCx">
        <h4 id="解题思路">解题思路</h4>
        <p>用指针去扫 <code>intervals</code>，最多可能有三个阶段：</p>
        <ol>
          <li>不重叠的绿区间，在蓝区间的左边</li>
          <li>有重叠的绿区间</li>
          <li>不重叠的绿区间，在蓝区间的右边</li>
        </ol>
        <p>
          <img
            src="https://pic.leetcode-cn.com/1604465027-kDWfBc-image.png"
            alt="image.png"
          />
        </p>
        <h4 id="逐个分析">逐个分析</h4>
        <ol>
          <li>
            <p>
              不重叠，需满足：绿区间的右端，位于蓝区间的左端的左边，如
              <code>[1,2]</code>。
            </p>
            <ul>
              <li>则当前绿区间，推入 res 数组，指针 +1，考察下一个绿区间。</li>
              <li>
                循环结束时，当前绿区间的屁股，就没落在蓝区间之前，有重叠了，如
                <code>[3,5]</code>。
              </li>
            </ul>
          </li>
          <li>
            <p>
              现在看重叠的。我们反过来想，没重叠，就要满足：绿区间的左端，落在蓝区间的屁股的后面，反之就有重叠：绿区间的左端
              &lt;= 蓝区间的右端，极端的例子就是 <code>[8,10]</code>。
            </p>
            <ul>
              <li>
                和蓝有重叠的区间，会合并成一个区间：左端取蓝绿左端的较小者，右端取蓝绿右端的较大者，不断更新给蓝区间。
              </li>
              <li>循环结束时，将蓝区间（它是合并后的新区间）推入 res 数组。</li>
            </ul>
          </li>
          <li>
            <p>
              剩下的，都在蓝区间右边，不重叠。不用额外判断，依次推入 res 数组。
            </p>
          </li>
        </ol>
        <h4 id="代码">代码</h4>
        <div
          class="border-gray-3 dark:border-dark-gray-3 mb-6 overflow-hidden rounded-lg border text-sm"
        >
          <div class="px-3 py-2.5 bg-fill-3 dark:bg-dark-fill-3">
            <div class="group relative" translate="no">
              <div class="absolute -right-1.5 -top-0.5 flex gap-2">
                <div
                  class="z-base-1 hidden rounded border group-hover:block border-border-quaternary dark:border-border-quaternary bg-layer-02 dark:bg-layer-02"
                >
                  <div
                    class="relative cursor-pointer flex h-[22px] w-[22px] items-center justify-center bg-layer-02 dark:bg-layer-02 hover:bg-fill-tertiary dark:hover:bg-fill-tertiary rounded-[4px]"
                    data-state="closed"
                  >
                    <div>
                      <div data-state="closed">
                        <div
                          class="relative text-[12px] leading-[normal] p-[1px] before:block before:h-3 before:w-3 h-3.5 w-3.5 text-text-primary dark:text-text-primary"
                        >
                          <svg
                            aria-hidden="true"
                            focusable="false"
                            data-prefix="far"
                            data-icon="clone"
                            class="svg-inline--fa fa-clone absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2"
                            role="img"
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 512 512"
                          >
                            <path
                              fill="currentColor"
                              d="M64 464H288c8.8 0 16-7.2 16-16V384h48v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V224c0-35.3 28.7-64 64-64h64v48H64c-8.8 0-16 7.2-16 16V448c0 8.8 7.2 16 16 16zM224 304H448c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H224c-8.8 0-16 7.2-16 16V288c0 8.8 7.2 16 16 16zm-64-16V64c0-35.3 28.7-64 64-64H448c35.3 0 64 28.7 64 64V288c0 35.3-28.7 64-64 64H224c-35.3 0-64-28.7-64-64z"
                            ></path>
                          </svg>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <p>
          <img
            src="https://pic.leetcode-cn.com/1604452312-Ysbyeh-image.png"
            alt="image.png"
          />
        </p>
        <h4 id="复盘总结">复盘总结</h4>
        <p>
          考察每个区间，为三种形态的区间安排三次 while
          循环，思考每个阶段所需满足的条件，并注意循环结束时的状态。<br />
          等号取不取，容易出错，画图看看怎么算有重叠。<br />
          合并区间时，新两端更新给蓝区间，无需引入新的变量。
        </p>
      </div>
    </div>
    <script>
      /**
       * @param {number[][]} intervals
       * @param {number[]} newInterval
       * @return {number[][]}
       */
      var insert = function (intervals, newInterval) {
        const res = [];
        let i = 0;
        const len = intervals.length;
        while (i < len && intervals[i][1] < newInterval[0]) {
          res.push(intervals[i]);
          i++;
        }
        while (i < len && intervals[i][0] <= newInterval[1]) {
          newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
          newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
          i++;
        }
        res.push(newInterval); // 循环结束后，兰区间为合并后的区间，推入res
        while (i < len) {
          res.push(intervals[i]);
          i++;
        }
        return res;
      };
      const intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]
      const newInterval = [4,8]
      const result = insert(intervals, newInterval);
      console.log("result: ", result);
    </script>
  </body>
</html>

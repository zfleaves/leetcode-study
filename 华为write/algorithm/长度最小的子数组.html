<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>长度最小的子数组</title>
    <link rel="stylesheet" href="../common.css" as="style" />
    <style>
        span.katex-mathml {
            display: none;
        }
    </style>
</head>

<body>
    <div class="elfjS" data-track-load="description_content"><p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>

        <p>找出该数组中满足其总和大于等于<strong> </strong><code>target</code><strong> </strong>的长度最小的 <strong>连续<span data-keyword="subarray-nonempty" class=" cursor-pointer relative text-dark-blue-s text-sm"><div class="popover-wrapper inline-block" data-headlessui-state=""><div><div aria-expanded="false" data-headlessui-state="" id="headlessui-popover-button-:r17:"><div>子数组</div></div><div style="position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(430px, 206px);"></div></div></div></span></strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
        
        <p>&nbsp;</p>
        
        <p><strong>示例 1：</strong></p>
        
        <pre><strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]
        <strong>输出：</strong>2
        <strong>解释：</strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的子数组。
        </pre>
        
        <p><strong>示例 2：</strong></p>
        
        <pre><strong>输入：</strong>target = 4, nums = [1,4,4]
        <strong>输出：</strong>1
        </pre>
        
        <p><strong>示例 3：</strong></p>
        
        <pre><strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]
        <strong>输出：</strong>0
        </pre>
        
        <p>&nbsp;</p>
        
        <p><strong>提示：</strong></p>
        
        <ul>
            <li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>
            <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
            <li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
        </ul>
        
        <p>&nbsp;</p>
        
        <p><strong>进阶：</strong></p>
        
        <ul>
            <li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
        </ul>
    </div>
    <div class="analysis">
        妙啊， 这个算法的核心思想在于。如果n1+n2+n3满足>=target，那么说明n1+n2是不满足的。所以left左指针往右移动，再判断是否满足，就能找到最小满足的了。
    </div>
    </div>
    <script>
        var minSubArrayLen = function(target, nums) {
            const n = nums.length;
            let ans = n + 1;
            let sum = 0; // 子数组元素和
            let left = 0; // 子数组左端点
            for (let right = 0; right < n; right++) { // 枚举子数组右端点
                sum += nums[right];
                while (sum - nums[left] >= target) { // 尽量缩小子数组长度
                    sum -= nums[left++]; // 左端点右移
                }
                if (sum >= target) {
                    ans = Math.min(ans, right - left + 1);
                }
            }
            return ans <= n ? ans : 0;
        };
        const nums = [2,3,1,2,4,3]
        const target = 7
        const result = minSubArrayLen(target, nums);
        console.log("result: ", result);
    </script>
</body>

</html>